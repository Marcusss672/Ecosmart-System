<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Restore Deleted Customers</title>
  <link rel="stylesheet" href="restore.css" />
  <link rel="stylesheet" href="restore2.css" />
</head>
<body>
  <!-- Header -->
  <header>
    <a href="dailyreport.html" class="back-button">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M19 12H5M5 12L12 19M5 12L12 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
    </a>
    <h1>Restore Deleted Records</h1>
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>
    </a>
  </header>

  <!-- Date Filter Controls (Enhanced with View Type like Daily Report) -->
  <div class="controls" style="display: flex; gap: 20px; margin: 20px; flex-wrap: wrap; align-items: center;">
    <div class="date-filter" style="display: flex; align-items: center; gap: 10px;">
      <input type="date" id="startDate" style="padding: 8px; border: 1px solid #4b723a; border-radius: 6px; background: rgba(46, 90, 65, 0.85); color: #e8f5e8;">
      <span style="color: #b8d4a8;">to</span>
      <input type="date" id="endDate" style="padding: 8px; border: 1px solid #4b723a; border-radius: 6px; background: rgba(46, 90, 65, 0.85);    color: #e8f5e8;">
      <select id="viewType" style="padding: 8px; border: 1px solid #4b723a; border-radius: 6px; background:rgba(46, 90, 65, 0.85);    color: #e8f5e8; position: relative; right: 1px;">
        <option value="daily">Daily View</option>
        <option value="weekly">Weekly View</option>
        <option value="monthly">Monthly View</option>
      </select>
      <button id="loadRestoreData" style="background: rgba(46, 90, 65, 0.85); color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer;">Load Data</button>
    </div>
  </div>

  <!-- Search and Filter Controls -->
  <div class="controls" style="display: flex; gap: 20px; margin: 20px; flex-wrap: wrap;">
    <input type="text" id="searchBox" class="search-box" placeholder="Search email, queue number, type, admin..." oninput="applyRestoreFilters()">

    <select id="transactionTypeFilter" onchange="applyRestoreFilters()">
      <option value="all">All Transactions</option>
      <option value="tuition">Tuition and Payments</option>
      <option value="graduates">Graduates</option>
      <option value="enrollment">Enrollment and Inquiries</option>
      <option value="schedule">Schedule</option>
      <option value="document">Request for Document</option>
      <option value="others">Others</option>
    </select>

    <select id="customerTypeFilter" onchange="applyRestoreFilters()">
      <option value="all">All Customer Types</option>
      <option value="regular">Regular</option>
      <option value="priority">Priority</option>
    </select>
  </div>

  <!-- Table -->
  <div class="table-section">
    <div class="table-header">
      <div class="table-title">Archived Customer Transactions</div>
      <div style="color: #b8d4a8; font-size: 14px; margin-top: 5px;">
        Showing <span id="filteredCount">0</span> of <span id="totalCount">0</span> records
      </div>
    </div>
    <div style="overflow-x: auto;">
      <table>
        <thead>
          <tr>
            <th>Queue #</th>
            <th>Email</th>
            <th>Transaction Type</th>
            <th>Customer Type</th>
            <th>Date Registerd</th>
            <th>Time Registered</th>
            <th>Time Started</th>
            <th>Time Completed</th>
            <th>Service Time</th>
            <th>Admin Handler</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="deletedTable">
          <tr><td colspan="11"><span class="loading"></span>Loading deleted records...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Firebase + Restore Logic -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js';
    import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyAn2WHhyPfyYV0rj5oZRo6MQK5HDbucIbo",
      authDomain: "queueing-8976a.firebaseapp.com",
      databaseURL: "https://queueing-8976a-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "queueing-8976a",
      storageBucket: "queueing-8976a.appspot.com",
      messagingSenderId: "10213448291",
      appId: "1:10213448291:web:2d07230ebe2fe2a9f0f656"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    const baseURL = "https://queueing-8976a-default-rtdb.asia-southeast1.firebasedatabase.app";

    let allDeletedData = [];
    let filteredDeletedData = [];

    // Set default dates based on view type
    function setDefaultDates() {
      const today = new Date();
      const viewType = document.getElementById('viewType').value;
      let startDate;

      switch (viewType) {
        case 'daily':
          startDate = new Date(today);
          break;
        case 'weekly':
          startDate = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case 'monthly':
          startDate = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
          break;
        default:
          startDate = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      }

      document.getElementById('startDate').valueAsDate = startDate;
      document.getElementById('endDate').valueAsDate = today;
    }

    // Initialize default dates
    setDefaultDates();

    // Event listeners
    document.getElementById('loadRestoreData').addEventListener('click', loadDeleted);
    document.getElementById('viewType').addEventListener('change', function() {
      setDefaultDates();
      // Automatically reload data when view type changes
      loadDeleted();
    });

    // Transaction type mapping function
    function getTransactionDetail(transactionType) {
      const types = {
        'tuition': 'Tuition and Payments',
        'graduates': 'Graduates',
        'enrollment': 'Enrollment and Inquiries',
        'schedule': 'Schedule',
        'document': 'Request for Document',
        'others': 'Others'
      };
      return types[transactionType] || transactionType;
    }



    // Calculate service time (from started to completed)
function calculateServiceTime(entry) {
    try {
        // Only calculate service time for completed transactions
        if (!entry.timeStarted || !entry.timeCompleted || 
            entry.timeCompleted === 'N/A' || entry.timeCompleted === 'In Progress' || 
            entry.timeCompleted === 'Waiting' || entry.timeStarted === 'Waiting' ||
            entry.timeStarted === 'In Progress') {
            return 0;
        }
        
        const startedTime = parseTimeString(entry.timeStarted, entry.date);
        const completedTime = parseTimeString(entry.timeCompleted, entry.date);
        
        if (startedTime && completedTime && completedTime > startedTime) {
            const serviceMinutes = Math.round((completedTime - startedTime) / (1000 * 60));
            return Math.max(0, serviceMinutes);
        }
        
        return 0;
    } catch (error) {
        console.error('Error calculating service time:', error);
        return 0;
    }
}

    // Enhanced time parsing function (same as daily report)
    function parseTimeString(timeStr, dateStr) {
      try {
        if (!timeStr || !dateStr || timeStr === 'N/A' || timeStr === 'Waiting' || timeStr === 'In Progress') {
          return null;
        }
        
        // Handle different date formats
        let dateParts;
        if (dateStr.includes('/')) {
          dateParts = dateStr.split('/');
        } else if (dateStr.includes('-')) {
          dateParts = dateStr.split('-');
          // Rearrange if in YYYY-MM-DD format
          if (dateParts[0].length === 4) {
            dateParts = [dateParts[1], dateParts[2], dateParts[0]];
          }
        } else {
          return null;
        }
        
        if (dateParts.length !== 3) return null;
        
        const month = parseInt(dateParts[0]) - 1; // Month is 0-indexed
        const day = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        
        // Parse time string (e.g., "10:30 AM" or "10:30:45 AM")
        const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)/i);
        if (!timeMatch) return null;
        
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3] || 0);
        const period = timeMatch[4].toUpperCase();
        
        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;
        
        return new Date(year, month, day, hours, minutes, seconds);
      } catch (error) {
        console.error('Error parsing time string:', timeStr, dateStr, error);
        return null;
      }
    }

    // Get current date in MM/DD/YYYY format
    function getCurrentDate() {
      const now = new Date();
      return `${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`;
    }

    // Check if date is within range based on view type
    function isDateInRange(entryDate, startDate, endDate, viewType) {
      // Basic range check
      if (entryDate < startDate || entryDate > endDate) {
        return false;
      }

      // Additional filtering based on view type
      switch (viewType) {
        case 'daily':
          // For daily view, show only entries from the selected date range
          return true;
        case 'weekly':
          // For weekly view, show entries from the past week
          return true;
        case 'monthly':
          // For monthly view, show entries from the past month
          return true;
        default:
          return true;
      }
    }

    // Load deleted records from Firebase with date filtering
    async function loadDeleted() {
      try {
        // Get selected date range and view type
        const startDate = new Date(document.getElementById('startDate').value);
        const endDate = new Date(document.getElementById('endDate').value);
        const viewType = document.getElementById('viewType').value;
        
        console.log('Loading deleted records from:', startDate, 'to', endDate, 'View:', viewType);

        const snapshot = await get(ref(database, "Deleted"));
        const table = document.getElementById("deletedTable");
        
        if (!snapshot.exists()) {
          table.innerHTML = "<tr><td colspan='11'>No archived records found.</td></tr>";
          document.getElementById('totalCount').textContent = '0';
          document.getElementById('filteredCount').textContent = '0';
          return;
        }

        const data = snapshot.val();
        allDeletedData = [];

        // Convert Firebase data to array with date filtering
        Object.entries(data).forEach(([key, value]) => {
          // Get entry date
          let entryDate;
          if (value.date) {
            // Parse MM/DD/YYYY format
            const dateParts = value.date.split('/');
            if (dateParts.length === 3) {
              const month = parseInt(dateParts[0]) - 1; // Month is 0-indexed
              const day = parseInt(dateParts[1]);
              const year = parseInt(dateParts[2]);
              entryDate = new Date(year, month, day);
            }
          } else if (value.timestamp) {
            entryDate = new Date(value.timestamp);
          } else {
            // Use current date as fallback
            entryDate = new Date();
          }

          // Check if entry date is within selected range and view type
          if (isDateInRange(entryDate, startDate, endDate, viewType)) {
            // Ensure we have all necessary fields
            const processedEntry = {
              queueNumber: value.queueNumber || key,
              email: value.email || "N/A",
              transactionType: value.transactionType || "others",
              priority: value.priority || (value.queueNumber && value.queueNumber.toString().toUpperCase().startsWith('P') ? 'priority' : 'regular'),
              date: value.date || getCurrentDate(),
              timeRegistered: value.timeRegistered || value.time || "N/A",
              timeStarted: value.timeStarted || "N/A",
              timeCompleted: value.timeCompleted || "N/A",
              adminHandler: value.adminHandler || value.handledBy || "N/A",
              source: value.source || "unknown",
              originalKey: key,
              serviceTime: calculateServiceTime(value)
            };
            allDeletedData.push(processedEntry);
          }
        });

        // Sort by most recent first
        allDeletedData.sort((a, b) => {
          const timeA = parseTimeString(a.timeRegistered, a.date);
          const timeB = parseTimeString(b.timeRegistered, b.date);
          if (timeA && timeB) {
            return timeB - timeA;
          }
          return (b.timeRegistered || '').localeCompare(a.timeRegistered || '');
        });

        // Update total count
        document.getElementById('totalCount').textContent = allDeletedData.length;

        // Apply initial filters
        applyRestoreFilters();

      } catch (error) {
        console.error('Error loading deleted records:', error);
        document.getElementById("deletedTable").innerHTML = 
          "<tr><td colspan='10'>Error loading archived records. Please try again.</td></tr>";
      }
    }

    // Apply search and filter functionality
    window.applyRestoreFilters = function() {
      const searchTerm = document.getElementById('searchBox').value.toLowerCase();
      const transactionFilter = document.getElementById('transactionTypeFilter').value;
      const customerTypeFilter = document.getElementById('customerTypeFilter').value;

      filteredDeletedData = allDeletedData.filter(entry => {
        // Search filter
        const matchesSearch = !searchTerm || 
          entry.email.toLowerCase().includes(searchTerm) ||
          entry.queueNumber.toLowerCase().includes(searchTerm) ||
          getTransactionDetail(entry.transactionType).toLowerCase().includes(searchTerm) ||
          entry.adminHandler.toLowerCase().includes(searchTerm);

        // Transaction type filter
        const matchesTransaction = transactionFilter === 'all' || 
          entry.transactionType === transactionFilter;

        // Customer type filter
        const matchesCustomerType = customerTypeFilter === 'all' || 
          entry.priority === customerTypeFilter;

        return matchesSearch && matchesTransaction && matchesCustomerType;
      });

      // Update filtered count
      document.getElementById('filteredCount').textContent = filteredDeletedData.length;

      // Update table display
      updateTable();
    };

    // Update table with filtered data
    function updateTable() {
      const table = document.getElementById("deletedTable");
      table.innerHTML = "";

      if (filteredDeletedData.length === 0) {
        table.innerHTML = "<tr><td colspan='11'>No records match your search criteria.</td></tr>";
        return;
      }

      filteredDeletedData.forEach((entry) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${entry.queueNumber}</td>
          <td>${entry.email}</td>
          <td>${getTransactionDetail(entry.transactionType)}</td>
          <td style="text-transform: capitalize;">${entry.priority}</td>
          <td>${entry.date}</td>
          <td>${entry.timeRegistered}</td>
          <td>${entry.timeStarted}</td>
          <td>${entry.timeCompleted}</td>
            <td>${entry.serviceTime} mins</td>
          <td>${entry.adminHandler}</td>
          <td>
            <button style="background: #4b723a; color: white; padding: 5px 10px; border: none; border-radius: 6px; cursor: pointer;" 
                    onclick="restoreTransaction('${entry.originalKey}', '${entry.source}')">
              Restore
            </button>
          </td>
        `;
        table.appendChild(row);
      });
    }

    // Restore transaction function
    window.restoreTransaction = async function(queueNumber, source) {
      try {
        if (!confirm(`Are you sure you want to restore Queue #${queueNumber}?`)) {
          return;
        }

        const res = await fetch(`${baseURL}/Deleted/${queueNumber}.json`);
        const data = await res.json();

        if (!data) {
          alert("Record not found.");
          return;
        }

        // Determine the correct source node to restore to
        let targetNode = source;
        if (!source || source === 'unknown') {
          // Default to 'done' if source is unknown
          targetNode = 'done';
        }

        // Restore to original location
        await fetch(`${baseURL}/${targetNode}/${queueNumber}.json`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data)
        });

        // Remove from deleted
        await fetch(`${baseURL}/Deleted/${queueNumber}.json`, {
          method: "DELETE"
        });

        alert(`Transaction Queue #${queueNumber} has been restored successfully!`);
        
        // Reload the data
        loadDeleted();

      } catch (error) {
        console.error('Error restoring transaction:', error);
        alert("Failed to restore transaction. Please try again.");
      }
    };

    // Initialize when page loads
    window.onload = loadDeleted;
  </script>
</body>
</html>